import math


class AES:
	def __init__(self):
		# structure of valid key sizes
		self.key_size = {
			'SIZE_128': 16,
			'SIZE_192': 24,
			'SIZE_256': 32
		}

		# Rijndael S-box
		self.sbox = [
			0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
			0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
			0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
			0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
			0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
			0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
			0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
			0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
			0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
			0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
			0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
			0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
			0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
			0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
			0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
			0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
		]

		# Rijndael Inverted S-box
		self.rsbox = [
			0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
			0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
			0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
			0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
			0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
			0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
			0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
			0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
			0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
			0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
			0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
			0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
			0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
			0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
			0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
			0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
		]

		# Rijndael Rcon
		self.rcon = [
			0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
			0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
			0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
			0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
			0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,
			0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
			0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,
			0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,
			0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
			0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,
			0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,
			0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
			0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
			0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
			0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
			0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
			0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,
			0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
			0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,
			0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb
		]

		self.g2x = [
			0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16,
			0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,
			0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46,
			0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
			0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76,
			0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e,
			0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6,
			0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
			0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6,
			0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee,
			0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d,
			0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
			0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d,
			0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55,
			0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d,
			0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
			0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d,
			0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5,
			0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd,
			0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
			0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed,
			0xe3, 0xe1, 0xe7, 0xe5
		]
		self.g3x = [
			0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d,
			0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39,
			0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65,
			0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
			0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d,
			0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9,
			0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5,
			0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
			0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd,
			0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99,
			0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e,
			0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
			0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6,
			0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2,
			0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce,
			0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
			0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46,
			0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62,
			0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e,
			0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
			0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16,
			0x1f, 0x1c, 0x19, 0x1a
		]
		self.g9x = [
			0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53,
			0x6c, 0x65, 0x7e, 0x77, 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf,
			0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 0x3b, 0x32, 0x29, 0x20,
			0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
			0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8,
			0xc7, 0xce, 0xd5, 0xdc, 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49,
			0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01, 0xe6, 0xef, 0xf4, 0xfd,
			0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
			0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e,
			0x21, 0x28, 0x33, 0x3a, 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2,
			0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 0xec, 0xe5, 0xfe, 0xf7,
			0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
			0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f,
			0x10, 0x19, 0x02, 0x0b, 0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8,
			0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 0x47, 0x4e, 0x55, 0x5c,
			0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
			0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9,
			0xf6, 0xff, 0xe4, 0xed, 0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35,
			0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 0xa1, 0xa8, 0xb3, 0xba,
			0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
			0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62,
			0x5d, 0x54, 0x4f, 0x46
		]
		self.gbx = [
			0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45,
			0x74, 0x7f, 0x62, 0x69, 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81,
			0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 0x7b, 0x70, 0x6d, 0x66,
			0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
			0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e,
			0xbf, 0xb4, 0xa9, 0xa2, 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7,
			0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 0x46, 0x4d, 0x50, 0x5b,
			0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
			0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8,
			0xf9, 0xf2, 0xef, 0xe4, 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c,
			0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 0xf7, 0xfc, 0xe1, 0xea,
			0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
			0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02,
			0x33, 0x38, 0x25, 0x2e, 0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd,
			0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 0x3c, 0x37, 0x2a, 0x21,
			0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
			0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44,
			0x75, 0x7e, 0x63, 0x68, 0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80,
			0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 0x7a, 0x71, 0x6c, 0x67,
			0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
			0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f,
			0xbe, 0xb5, 0xa8, 0xa3
		]
		self.gdx = [
			0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f,
			0x5c, 0x51, 0x46, 0x4b, 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3,
			0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 0xbb, 0xb6, 0xa1, 0xac,
			0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
			0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14,
			0x37, 0x3a, 0x2d, 0x20, 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e,
			0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 0xbd, 0xb0, 0xa7, 0xaa,
			0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
			0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9,
			0x8a, 0x87, 0x90, 0x9d, 0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25,
			0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 0xda, 0xd7, 0xc0, 0xcd,
			0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
			0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75,
			0x56, 0x5b, 0x4c, 0x41, 0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42,
			0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 0xb1, 0xbc, 0xab, 0xa6,
			0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
			0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8,
			0xeb, 0xe6, 0xf1, 0xfc, 0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44,
			0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 0x0c, 0x01, 0x16, 0x1b,
			0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
			0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3,
			0x80, 0x8d, 0x9a, 0x97
		]
		self.gex = [
			0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62,
			0x48, 0x46, 0x54, 0x5a, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca,
			0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 0xdb, 0xd5, 0xc7, 0xc9,
			0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
			0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59,
			0x73, 0x7d, 0x6f, 0x61, 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87,
			0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 0x4d, 0x43, 0x51, 0x5f,
			0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
			0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14,
			0x3e, 0x30, 0x22, 0x2c, 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc,
			0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 0x41, 0x4f, 0x5d, 0x53,
			0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
			0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3,
			0xe9, 0xe7, 0xf5, 0xfb, 0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0,
			0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 0x7a, 0x74, 0x66, 0x68,
			0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
			0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e,
			0xa4, 0xaa, 0xb8, 0xb6, 0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26,
			0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 0x37, 0x39, 0x2b, 0x25,
			0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
			0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5,
			0x9f, 0x91, 0x83, 0x8d
		]

	# Rotate the word eight bits to the left
	@staticmethod
	def rotate(word):
		c = word[0]
		for i in range(3):
			word[i] = word[i + 1]
		word[3] = c

		return word

	# Key Schedule Core
	def core(self, word, iteration):
		# Rotate the 32-bit word 8 bits to the left
		word = self.rotate(word)

		# Apply S-Box substitution on all 4 parts of the 32-bit word
		for i in range(4):
			word[i] = self.sbox[word[i]]

		# XOR the output of the rcon operation with i to the first part (leftmost) only
		word[0] ^= self.rcon[iteration]

		return word

	# Rijndael's key expansion
	# expands an 128,192,256 key into an 176,208,240 bytes key
	#
	# expandedKey is a pointer to a char array of large enough size
	# key is a pointer to a non-expanded key
	def expand_key(self, key, size):
		expanded_key_size = 16 * (self.number_of_rounds(size) + 1)

		# current expanded key_size, in bytes
		current_size = 0
		rcon_iteration = 1
		t = [0] * 4  # temporary 4 - byte variable

		expanded_key = [0] * expanded_key_size

		# set the 16, 24, 32 bytes of the expanded key to the input key
		for j in range(size):
			expanded_key[j] = key[j]

		current_size += size

		while current_size < expanded_key_size:
			# assign the previous 4 bytes to the temporary value t
			for k in range(4):
				t[k] = expanded_key[current_size - 4 + k]

			# every 16, 24, 32 bytes we apply the core schedule to t
			# and increment rcon_iteration afterwards
			if current_size % size == 0:
				t = self.core(t, rcon_iteration)
				rcon_iteration += 1

			# For 256-bit keys, we add an extra sbox to the calculation
			if size == self.key_size['SIZE_256'] and current_size % size == 16:
				for l in range(4):
					t[l] = self.sbox[t[l]]

			# We XOR t with the four-byte block 16,24,32 bytes before the new expanded key.
			# This becomes the next four bytes in the expanded key.
			for m in range(4):
				expanded_key[current_size] = expanded_key[current_size - size] ^ t[m]
				current_size += 1

		return expanded_key

	# Adds (XORs) the round key to the state
	@staticmethod
	def add_round_key(state, round_key):
		for i in range(16):
			state[i] ^= round_key[i]
		return state

	# Creates a round key from the given expanded key and the
	# position within the expanded key.
	@staticmethod
	def create_round_key(expanded_key, round_key_pointer):
		round_key = [0] * 16
		for i in range(4):
			for j in range(4):
				round_key[j * 4 + i] = expanded_key[round_key_pointer + i * 4 + j]
		return round_key

	# substitute all the values from the state with the value in the SBox
	# using the state value as index for the SBox
	def sub_bytes(self, state, is_inv):
		for i in range(16):
			state[i] = self.rsbox[state[i]] if is_inv else self.sbox[state[i]]
		return state

	# iterate over the 4 rows and call shiftRow() with that row
	def shift_rows(self, state, is_inv):
		for i in range(4):
			state = self.shift_row(state, i * 4, i, is_inv)
		return state

	# each iteration shifts the row to the left by 1
	@staticmethod
	def shift_row(state, state_pointer, nbr, is_inv):
		for i in range(nbr):
			if is_inv:
				tmp = state[state_pointer + 3]
				for j in range(3, 0, -1):
					state[state_pointer + j] = state[state_pointer + j - 1]
				state[state_pointer] = tmp
			else:
				tmp = state[state_pointer]
				for j in range(3):
					state[state_pointer + j] = state[state_pointer + j + 1]
				state[state_pointer + 3] = tmp

		return state

	# galois multiplication of 8 bit characters a and b
	@staticmethod
	def galois_multiplication(a, b):
		p = 0
		for counter in range(8):
			if b & 1 == 1:
				p ^= a
			if p > 0x100:
				p ^= 0x100
			hi_bit_set = a & 0x80  # keep p 8 bit
			a <<= 1
			if a > 0x100:
				a ^= 0x100  # keep a 8 bit
			if hi_bit_set == 0x80:
				a ^= 0x1b
			if a > 0x100:
				a ^= 0x100  # keep a 8 bit
			b >>= 1
			if b > 0x100:
				b ^= 0x100  # keep b 8 bit
		return p

	# galois multiplication of the 4x4 matrix
	def mix_columns(self, state, is_inv):
		# iterate over the 4 columns
		for i in range(4):
			column = [0] * 4
			# construct one column by iterating over the 4 rows
			for j in range(4):
				column[j] = state[j * 4 + i]
			# apply the mix_column on one column
			column = self.mix_column(column, is_inv)

			# put the values back into the state
			for k in range(4):
				state[k * 4 + i] = column[k]

		return state

	# galois multiplication of 1 column of the 4x4 matrix
	def mix_column(self, column, is_inv):
		if is_inv:
			mult = [14, 9, 13, 11]
		else:
			mult = [2, 1, 1, 3]

		cpy = column.copy()

		column[0] = self.galois_multiplication(cpy[0], mult[0]) ^ self.galois_multiplication(cpy[3], mult[1]) ^ \
		            self.galois_multiplication(cpy[2], mult[2]) ^ self.galois_multiplication(cpy[1], mult[3])

		column[1] = self.galois_multiplication(cpy[1], mult[0]) ^ self.galois_multiplication(cpy[0], mult[1]) ^ \
		            self.galois_multiplication(cpy[3], mult[2]) ^ self.galois_multiplication(cpy[2], mult[3])

		column[2] = self.galois_multiplication(cpy[2], mult[0]) ^ self.galois_multiplication(cpy[1], mult[1]) ^ \
		            self.galois_multiplication(cpy[0], mult[2]) ^ self.galois_multiplication(cpy[3], mult[3])

		column[3] = self.galois_multiplication(cpy[3], mult[0]) ^ self.galois_multiplication(cpy[2], mult[1]) ^ \
		            self.galois_multiplication(cpy[1], mult[2]) ^ self.galois_multiplication(cpy[0], mult[3])

		return column

	# applies the 4 operations of the forward round in sequence
	def round(self, state, round_key):
		state = self.sub_bytes(state, False)
		state = self.shift_rows(state, False)
		state = self.mix_columns(state, False)
		state = self.add_round_key(state, round_key)
		return state

	# applies the 4 operations of the inverse round in sequence
	def inv_round(self, state, round_key):
		state = self.shift_rows(state, True)
		state = self.sub_bytes(state, True)
		state = self.add_round_key(state, round_key)
		state = self.mix_columns(state, True)
		return state

	# Perform the initial operations, the standard round, and the final operations
	# of the forward aes, creating a round key for each round
	def main(self, state, expanded_key, nbr_rounds):
		state = self.add_round_key(state, self.create_round_key(expanded_key, 0))
		for i in range(1, nbr_rounds):
			state = self.round(state, self.create_round_key(expanded_key, 16 * i))
		state = self.sub_bytes(state, False)
		state = self.shift_rows(state, False)
		state = self.add_round_key(state, self.create_round_key(expanded_key, 16 * nbr_rounds))
		return state

	# Perform the initial operations, the standard round, and the final operations
	# of the inverse aes, creating a round key for each round
	def inv_main(self, state, expanded_key, nbr_rounds):
		state = self.add_round_key(state, self.create_round_key(expanded_key, 16 * nbr_rounds))
		for i in range(nbr_rounds - 1, 0, -1):
			state = self.inv_round(state, self.create_round_key(expanded_key, 16 * i))
		state = self.shift_rows(state, True)
		state = self.sub_bytes(state, True)
		state = self.add_round_key(state, self.create_round_key(expanded_key, 0))
		return state

	def number_of_rounds(self, size):
		if size == self.key_size['SIZE_128']:
			nbr_rounds = 10
		elif size == self.key_size['SIZE_192']:
			nbr_rounds = 12
		elif size == self.key_size['SIZE_256']:
			nbr_rounds = 14
		else:
			return

		return nbr_rounds

	# encrypts a 128 bit input block against the given key of size specified
	def encrypt(self, input_data, key, size):
		output = []
		block = []
		nbr_rounds = self.number_of_rounds(size)

		# Set the block values
		for i in range(4):  # iterate over the columns
			for j in range(4):  # iterate over the rows
				block.append(input_data[i * 4 + j])

		# Expand the key into an 176, 208, 240 bytes key
		expanded_key = self.expand_key(key, size)

		# Encrypt the block using the expanded key
		block = self.main(block, expanded_key, nbr_rounds)
		for k in range(4):  # unmap the block again into the output
			for l in range(4):  # iterate over the rows
				output.append(block[k + (l * 4)])

		return output

	def decrypt(self, input_data, key, size):
		output = [0] * 16
		block = [0] * 16  # the 128-bit block to encode
		nbr_rounds = self.number_of_rounds(size)

		# Set the block values
		for i in range(4):  # iterate over the columns
			for j in range(4):  # iterate over the rows
				block[(i + (j * 4))] = input_data[(i * 4) + j]

		# Expand the key into an 176, 208, 240 bytes key
		expanded_key = self.expand_key(key, size)

		# Encrypt the block using the expanded key
		block = self.inv_main(block, expanded_key, nbr_rounds)
		for k in range(4):  # unmap the block again into the output
			for l in range(4):  # iterate over the rows
				output[(k * 4) + l] = block[(k + (l * 4))]

		return output


class SlowAES:
	def __init__(self):
		self.aes = AES()

		# structure of supported modes of operation
		self.mode_of_operation = {
			'OFB': 0,
			'CFB': 1,
			'CBC': 2
		}

	# get a 16 byte block (aes operates on 128bits)
	@staticmethod
	def get_block(bytes_in, start, end):
		if end - start > 16:
			end = start + 16

		return bytes_in[start:end]

	# Mode of Operation Encryption
	# bytesIn - Input String as array of bytes
	# mode - mode of type modeOfOperation
	# key - a number array of length 'size'
	# size - the bit length of the key
	# iv - the 128-bit number array Initialization Vector
	def encrypt(self, bytes_in, mode, key, iv):
		size = len(key)
		if len(iv) % 16:
			raise ValueError('IV length must be 128 bits.')

		# the AES input/output
		input_data = []
		output = []
		ciphertext = []
		cipher_out = []

		# char firstRound
		first_round = True
		if mode == self.mode_of_operation['CBC']:
			bytes_in = self.pad_bytes_in(bytes_in)
		if bytes_in:
			for j in range((len(bytes_in) + 15) // 16):
				start = j * 16
				end = j * 16 + 16
				if j * 16 + 16 > len(bytes_in):
					end = len(bytes_in)

				byte_array = self.get_block(bytes_in, start, end)
				if mode == self.mode_of_operation['CFB']:
					if first_round:
						output = self.aes.encrypt(iv, key, size)
						first_round = False
					else:
						output = self.aes.encrypt(input_data, key, size)

					for i in range(16):
						ciphertext[i] = byte_array[i] ^ output[i]
					for k in range(end - start):
						cipher_out.append(ciphertext[k])
					input_data = ciphertext

				elif mode == self.mode_of_operation['OFB']:
					if first_round:
						output = self.aes.encrypt(iv, key, size)
						first_round = False
					else:
						output = self.aes.encrypt(input_data, key, size)
					for i in range(16):
						ciphertext[i] = byte_array[i] ^ output[i]
					for k in range(end - start):
						cipher_out.append(ciphertext[k])
					input_data = output

				elif mode == self.mode_of_operation['CBC']:
					for i in range(16):
						input_data[i] = byte_array[i] ^ (iv[i] if first_round else output[i])
					first_round = False
					ciphertext = self.aes.encrypt(input_data, key, size)

					# always 16 bytes because of the padding for CBC
					for k in range(16):
						cipher_out.append(ciphertext[k])

		return cipher_out

	# Mode of Operation Decryption
	# cipherIn - Encrypted String as array of bytes
	# originalsize - The unencrypted string length - required for CBC
	# mode - mode of type modeOfOperation
	# key - a number array of length 'size'
	# size - the bit length of the key
	# iv - the 128-bit number array Initialization Vector
	def decrypt(self, cipher_in, mode, key, iv):
		size = len(key)
		if len(iv) % 16:
			raise ValueError('IV length must be 128 bits.')

		# the AES input/output
		input_data = []
		byte_array = []
		bytes_out = []

		# char firstRound
		first_round = True
		if cipher_in:
			for j in range(math.ceil(len(cipher_in) / 16)):
				start = j * 16
				end = j * 16 + 16
				if j * 16 + 16 > len(cipher_in):
					end = len(cipher_in)

				ciphertext = self.get_block(cipher_in, start, end)
				if mode == self.mode_of_operation['CFB']:
					if first_round:
						output = self.aes.encrypt(iv, key, size)
						first_round = False
					else:
						output = self.aes.encrypt(input_data, key, size)
					for i in range(16):
						byte_array[i] = output[i] ^ ciphertext[i]
					for k in range(end - start):
						bytes_out.append(byte_array[k])
					input_data = ciphertext

				elif mode == self.mode_of_operation['OFB']:
					if first_round:
						output = self.aes.encrypt(iv, key, size)
						first_round = False
					else:
						output = self.aes.encrypt(input_data, key, size)
					for i in range(16):
						byte_array[i] = output[i] ^ ciphertext[i]
					for k in range(end - start):
						bytes_out.append(byte_array[k])
					input_data = output

				elif mode == self.mode_of_operation['CBC']:
					output = self.aes.decrypt(ciphertext, key, size)
					for i in range(16):
						byte_array.append((iv[i] if first_round else input_data[i]) ^ output[i])
					first_round = False
					for k in range(end - start):
						bytes_out.append(byte_array[k])
					input_data = ciphertext

			# if mode == self.mode_of_operation['CBC']:
			# 	print(bytes_out)
			# 	bytes_out = self.unpad_bytes_out(bytes_out)
			# 	print(bytes_out)

		return bytes_out

	@staticmethod
	def pad_bytes_in(data):
		data_len = len(data)
		pad_byte = 16 - (data_len % 16)
		for _ in range(pad_byte):
			data.append(pad_byte)

		return data

	@staticmethod
	def unpad_bytes_out(data):
		pad_count = 0
		pad_byte = -1
		block_size = 16

		if len(data) > 16:
			for i in range(len(data) - 1, len(data) - 1 - block_size, -1):
				if data[i] <= block_size:
					if pad_byte == -1:
						pad_byte = data[i]
					if data[i] != pad_byte:
						pad_count = 0
						break
					pad_count += 1
				else:
					break
				if pad_count == pad_byte:
					break

		if pad_count > 0:
			data = data[len(data) - pad_count:]

		return data


def to_numbers(d):
	e = []
	pairs = [d[i:i + 2] for i in range(0, len(d), 2)]
	for pair in pairs:
		e.append(int(pair, 16))
	return e


def to_hex(arg):
	e = ''
	for num in arg:
		e += (format(num, '02x'))
	return e.lower()


def compute_cookie(a_hash: str, b_hash: str, c_hash: str, mode: int) -> str:
	a = to_numbers(a_hash)
	b = to_numbers(b_hash)
	c = to_numbers(c_hash)
	return to_hex(SlowAES().decrypt(c, mode, a, b))


if __name__ == '__main__':
	print(compute_cookie(
		a_hash='f513d0396b356daca2fec927b3ba8f17',
		b_hash='c5fbcdd782cc5efd667583a0abe27eb1',
		c_hash='f51e322c2f5071239802df9c7970bf70',
		mode=2
	))
